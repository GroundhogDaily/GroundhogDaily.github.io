<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://GroundhogDaily.github.io</id>
    <title>笔记</title>
    <updated>2019-11-16T01:31:13.557Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://GroundhogDaily.github.io"/>
    <link rel="self" href="https://GroundhogDaily.github.io/atom.xml"/>
    <subtitle>没有伞的孩子要努力奔跑</subtitle>
    <logo>https://GroundhogDaily.github.io/images/avatar.png</logo>
    <icon>https://GroundhogDaily.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 笔记</rights>
    <entry>
        <title type="html"><![CDATA[Java多线程基础]]></title>
        <id>https://GroundhogDaily.github.io/post/java-duo-xian-cheng-ji-chu</id>
        <link href="https://GroundhogDaily.github.io/post/java-duo-xian-cheng-ji-chu">
        </link>
        <updated>2019-11-16T01:28:57.000Z</updated>
        <content type="html"><![CDATA[<h4 id="使用多线程的方法">使用多线程的方法</h4>
<p>继承Thread类</p>
<p>实现runnable接口</p>
<h4 id="线程常用方法thread类和object类">线程常用方法(Thread类和Object类)</h4>
<p>这些方法要注意当前线程和该线程表述，当前线程即正在执行该代码段的线程，该线程指调用该方法的那个线程。</p>
<p>一般静态Thread方法调用是调用当前正在执行的线程，直接通过类名调用即可。</p>
<pre><code class="language-java">static Thread currentThread();
Thread.currentThread().getName()
</code></pre>
<p>返回当前正在执行的线程名，currentThread()是返回当前正在执行的线程。</p>
<pre><code class="language-java">boolean isAlive()
</code></pre>
<p>判断该线程是否是否处于活跃状态，即正在运行或准备运行的状态。</p>
<pre><code class="language-java">static void sleep(long millis)
</code></pre>
<p>在指定的毫秒数内让当前正在执行的线程休眠，该方法不会让线程释放锁。</p>
<pre><code class="language-java">long getId()
</code></pre>
<p>返回该线程的标识符，线程ID唯一不变，线程终止时，该线程ID可以被重新使用。</p>
<pre><code class="language-java">void interrupt()
</code></pre>
<p>中断线程，该方法不会使正在运行的线程停止，只是改变中断标志，而对于改变了中断标志的线程，调用wait，sleep，join方法时会抛出异常。如果线程在调用 Object 类的 wait()、wait(long) 或 wait(long, int) 方法，或者该类的 join()、join(long)、join(long, int)、sleep(long) 或 sleep(long, int) 方法过程中受阻，则其中断状态将被清除，它还将收到一个 InterruptedException。</p>
<p>该方法主要作用是让处于wait，sleep，join状态的线程退出，让线程提早结束。但会抛出异常（中断状态也会被清除），后面的语句也不再执行，如果有需要，可以在catch语句块中编写要执行的代码。</p>
<pre><code class="language-java">static boolean interrupted()
</code></pre>
<p>判断当前正在执行的线程是否处于中断状态，并清除中断状态，可以与interrupt方法一起使用使线程停止（抛出异常的方式或return）。</p>
<p>interrupt方法可以在其他地方通过线程引用调用设置中断，在该线程执行时即可判断是否中断并作出响应。</p>
<pre><code class="language-java">boolean isInterrupted()
</code></pre>
<p>测试线程是否已经中断，不改变中断状态。</p>
<pre><code class="language-java">static void yield()
</code></pre>
<p>暂停当前正在执行的线程对象，并执行其他线程。即让出cpu资源，并处于就绪状态等待cpu资源。</p>
<pre><code class="language-java">final void setPriority(int newPriority)

</code></pre>
<p>更改线程的优先级（1-10）。</p>
<p>在Java中，线程优先级具有继承性，比如A线程启动B线程，则B线程的优先级与A是一样的。</p>
<pre><code class="language-java">final int getPriority()

</code></pre>
<p>返回线程的优先级。</p>
<pre><code class="language-java">final void join()

</code></pre>
<p>等待该线程终止，并释放锁。</p>
<pre><code class="language-java">final wait void wait()

</code></pre>
<p>Object方法，使线程等待，将线程加入“预执行队列”中，并释放锁，只能在同步语句块中使用。</p>
<p>为防止出现通知过早等问题，该方法需要在循环中使用，一般用while语句加上标识符。</p>
<pre><code class="language-java">final void notify()

</code></pre>
<p>Object方法，唤醒在此对象监视器上等待的单个线程（随机唤醒一个），被唤醒的线程加入就绪队列，等待当前线程释放锁，必须在同步语句块中使用，</p>
<pre><code class="language-java">final void notifyAll()

</code></pre>
<p>Object方法，唤醒在此对象监视器上等待的所有线程，必须在同步语句块中使用。</p>
<p>上述三个方法可以实现线程间通信的功能，生产者与消费者则需用到notifyAll唤醒所有等待的线程，否则会产生循环等待的问题，即生产者唤醒生产者，消费者唤醒消费者。</p>
<h4 id="生产者和消费者模型">生产者和消费者模型</h4>
<pre><code class="language-java">/*
简述：由生产者和消费者共同维护一个缓冲区，生产者负责向缓冲区添加消息，消费者从缓冲区消费消息，生产者和消费者线程通过缓冲区进行单向通信。
使用wait/notifyAll实现的模型，同一时间只有一个线程操作缓冲区（wait/notifyAll都要在同步块中使用），这里唤醒和等待都要基于同一个锁对象才有意义。
*/
class Person{
	private int foodNum = 0;//缓冲区
    private Object synObj = new Object();//锁对象
    Private final int MAX_NUM = 10;//缓冲区大小
    
    在wait时中断抛出异常
    public void produce() throws InterruptedException{
        synchronized(synObj){
            //这里必须用while，如果出现生产者唤醒生产者这种情况，则继续等待，下面consume同理
            while(foodNum == MAX_NUM){
                synObj.wait();
            }
            foodNum ++;//生产消息
            synObj.notifyAll();//唤醒所有线程，也必须使用该方法唤醒所有等待线程
        }
    }
    
    public void consume() throws InterruptedException{
        synchronized(synObj){
            while(foodNum == 0){
                synObj.wait();
            }
            foodNum--;//消费消息
            synObj.notifyAll();
        }
    }	
}

class Producer implements Runnable{
	Person person ;
    
    public Producer(Person person){
        this.person = person;
    }
    
    public void run(){
        while(true){//根据具体业务而定
            //发生中断时会抛出异常，提前结束等待（调用interrupt方法，中断当前线程），所以需要     		   //在出现这种情况时进行相应的处理，有时候业务需要提前结束等待。
            try{
            	person.produce();
        	}catch(InterruptedException e){
            	e.printStackTrace();
       		}
        }
    }
}

class Consumer implements Runnable{
    Person person;
    
    public Consumer(Person person){
        this.person = person;
    }
    
    public void run(){
        while(true){
            try{
            	person.consume();
        	}catch(InterruptedException e){
            	e.printStackTrace();
       		}
        }
    }
}

</code></pre>
<h4 id="通过管道进行线程间通信">通过管道进行线程间通信</h4>
<pre><code class="language-Java">PipedInputStream（从输入流中读取数据） PipedOutputStream //字节流
PipedReader PipedWriter //字符流
//四个类都有connect方法，用于相互连接，一个线程通过PipedOutputStream或PipedWriter向流输入数据，另一个线程取数据
//管道输入流包含一个缓冲区，可在缓冲区限定的范围内将读操作和写操作分离开。

</code></pre>
<h4 id="lock的使用显式锁">Lock的使用(显式锁)</h4>
<h5 id="reentrantlock">ReentrantLock</h5>
<pre><code class="language-Java">/*
ReentrantLock:一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。 
*/
//典型代码
public class Demo{
    private final Lock lock = new ReentrantLock();
    public void test(){
        lock.lock();
        //lock获取锁后运行代码，当抛出异常时不像synchronized一样，自动释放锁，所以需要try语句保证最后能释放锁，不然会有死锁的可能。
        try{
            //do something ...
        }finally{
            lock.unlock();
        }
    }
}

</code></pre>
<h4 id="与lock关联的condition">与Lock关联的Condition</h4>
<p>理解：conditon通过lock.newCondition()创建，实现了粒度更细的等待/通知模型。一个Lock对象可以创建多个Condition,而一个Condition可以和多个线程关联，实现了范围性的等待/通知。</p>
<p>线程执行到condition.await()时等待并释放锁，另一个线程通过condition.signal()/condition.signalAll()唤醒同一个condition内等待的线程。一个condition即为一个条件队列，通过调用不同的condition即可唤醒不同的条件队列等待的线程。</p>
<pre><code class="language-java">public class demo{
	private final Lock lock = new ReetrantLock();
    private Condition conditon1 = lock.newConditon();
    private Condition condition2 = lock.newConditon();
    
    public void await1(){
        lock.lock();
        try{
            do something ...
            condition1.await();
            do something ...
        }catch(InterruptedException e){
            e.prinStackTrace();
        }finally{
            lock.unlock();
        }
    }
    
    public void await2(){
        lock.lock();
        try{
            do something ...
            condition12.await();
            do something ...
        }catch(InterruptedException e){
            e.prinStackTrace();
        }finally{
            lock.unlock();
        }
    }
    
    public void signal1(){
        lock.lock();
        try{
            do something ...
            condition11.signalAll();
            do something ...
        }finally{
            lock.unlock();
        }
    }
    
     public void signal2(){
        lock.lock();
        try{
            do something ...
            condition12.signalAll();
            do something ...
        }finally{
            lock.unlock();
        }
    }
}

</code></pre>
<h5 id="公平锁和非公平锁">公平锁和非公平锁</h5>
<p>锁Lock分为“公平锁”和“非公平锁”，公平锁表示线程获取锁的顺序是按照FIFO先进先出的顺序，非公平锁则是一种获取锁的抢占机制，随机获取锁。</p>
<pre><code class="language-java">lock = new ReentrantLock(true)//设为公平锁，默认为false

</code></pre>
<h5 id="有条件的执行线程">有条件的执行线程</h5>
<pre><code class="language-java"> boolean tryLock()

</code></pre>
<p>仅在调用时锁未被另一个线程保持的情况下，才获取该锁。 如果锁被另一个线程保持，则此方法将立即返回 false 值。 与lock()不同的是，他不会等待获取锁，而是直接返回false。</p>
<pre><code class="language-java">boolean tryLock(long timeout,TimeUnit unit) throws InterruptedException

</code></pre>
<p>如果锁在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁。</p>
<p>因为此方法是一个显式中断点，所以要优先考虑响应中断，而不是响应锁的普通获取或重入获取，或者报告所用的等待时间。</p>
<p>理解：lock锁可实现有条件，有时间限制的获取锁，在中断情况下放弃执行后面的同步代码块，并抛出异常，在实现时可通过设置中断有条件的让一个线程是否执行同步代码。</p>
<h5 id="conditon部分方法">Conditon部分方法</h5>
<pre><code class="language-java">void awaitUninterruptibly()	

</code></pre>
<p>造成当前线程在接到信号之前一直处于等待状态。被中断后不抛出异常，继续执行。</p>
<p>这里注意，await()方法在中断时会抛出异常，而此方法中断相当于唤醒当前线程的信号，即在中断，signal()，signalAll()唤醒当前线程前一直处于等待状态。</p>
<pre><code class="language-Java">boolean awaitUntil(Date deadline) throws InterruptedException

</code></pre>
<p>造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。 中断后抛出异常。</p>
<h5 id="reentrantreadwritelock">ReentrantReadWriteLock</h5>
<p>读写锁，与ReentrantLock不同的是，读写锁表示有两个锁，一个是读操作相关的锁，另一个是写相关操作的锁。多个读锁之间不互斥，读锁与写锁互斥，写锁和写锁互斥</p>
<p>在某些不需要操作实例变量的方法中，可以使用读锁提高运行速度。</p>
<pre><code>lock.readLock().lock();//获得读锁
lock.readLock().unlock();//释放读锁
lock.writeLock.lock();//获得写锁
lock.writeLock().unlock();//释放读锁

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java虚拟机]]></title>
        <id>https://GroundhogDaily.github.io/post/java-xu-ni-ji</id>
        <link href="https://GroundhogDaily.github.io/post/java-xu-ni-ji">
        </link>
        <updated>2019-11-10T08:40:06.000Z</updated>
        <content type="html"><![CDATA[<h4 id="虚拟机内存划分">虚拟机内存划分</h4>
<ol>
<li>程序计数器</li>
</ol>
<p>计数器记录了正在执行的虚拟机字节码指令的地址，如果执行的是native方法，计数器值为空</p>
<ol start="2">
<li>Java虚拟机栈</li>
</ol>
<p>虚拟机栈描述的是Java方法执行的内存模型，每一个方法从调用到执行完成的过程，对应着一个栈帧在虚拟机中入栈到出栈的过程虚拟机栈不可以动态扩展时，如果线程请求的栈深度大于虚拟机所允许的深度，会抛出StackOverflowError异常。虚拟机栈动态扩展时，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<ol start="3">
<li>本地方法栈</li>
</ol>
<p>与虚拟机栈相似，不过对应的是native方法服务，同样会抛出上述异常。</p>
<ol start="4">
<li>Java堆</li>
</ol>
<p>存放对象实例，逻辑上是连续的，物理上 不一定连续，可通过-Xmx和-Xms扩展</p>
<ol start="5">
<li>方法区</li>
</ol>
<p>用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。</p>
<ol start="6">
<li>运行时常量池</li>
</ol>
<p>用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法去的运行时常量池中存放，以及string常量，常用于intern方法（当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（用 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并返回此 String 对象的引用。）</p>
<hr>
<h4 id="对象的创建过程p45">对象的创建过程（p45）</h4>
<p>虚拟机遇到一个new指令后，首先检查该指令参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载，解析初始化，如果没有则执行类加载过程。</p>
<h5 id="对象的访问定位java程序需要通过栈上的reference数据来操作堆上的具体对象">对象的访问定位（Java程序需要通过栈上的reference数据来操作堆上的具体对象）</h5>
<ol>
<li>句柄方式</li>
</ol>
<p>Java堆中会划分出一块内存来作为句柄池，reference中存储了对象的句柄地址，而句柄包含了对象的具体地址。</p>
<ol start="2">
<li>直接指针访问</li>
</ol>
<p>Reference中存储了对象的的真实地址</p>
<p>优劣：对象被移动只会改变句柄钟到实例数据指针，reference不需要修改，直接指针速度快。</p>
<hr>
<h4 id="垃圾回收算法">垃圾回收算法</h4>
<ol>
<li>引用计数算法</li>
</ol>
<p>对象保存一个引用计数器，每当有一个地方引用它时，计数器值加一，引用是失效时则减一，为0则不在被使用，缺点是难以解决循环引用的问题。</p>
<ol start="2">
<li>可达性分析算法</li>
</ol>
<p>通过称为“GC root”的对象为起始点，从这些起始点向下搜索，当一个对象到GC root 没有任何引用链相连，则这个对象是不可达的，在枚举根节点分析时保证对象引用关系不变化，所以会造成停顿。</p>
<p>GC root对象：</p>
<p>a.  虚拟机栈中引用的对象</p>
<p>b.  方法区中静态变量属性引用的对象</p>
<p>c.  方法区中常量引用的对象</p>
<p>d.  本地方法栈中引用的对象</p>
<ol start="3">
<li>标记清除算法</li>
</ol>
<p>标记完后续统一回收，但标记清除效率不高，会产生大量不连续的内存碎片，该算法是GC的基础。</p>
<ol start="4">
<li>复制算法</li>
</ol>
<p>Java中将堆分为新生代和老年代，新生代又分为Eden和两个servivor空间，每次将存活对象复制到另一个servivor中，如果servivor空间不足，则由老年代进行分配担保，存储这些对象。</p>
<ol start="5">
<li>标记整理算法</li>
</ol>
<p>该算法工作在老年代，在标记后将存活对象向一端移动，清理另一边的内存，以应对对象存活率较高的情况。</p>
<ol start="6">
<li>分代收集算法</li>
</ol>
<p>即将堆分为新生代和老年代，再在不同代的堆运行不同的算法，新生代采用复制算法，老年代使用标记清除或者标记整理算法。</p>
<hr>
<h4 id="对象回收过程">对象回收过程</h4>
<p>首先进行可达性分析，这里会造成GC停顿，停顿指的是线程执行到安全点停顿，如果对象不可达，则开始第一次标记筛选，筛选条件是是否有必要执行finalize方法，如果覆盖了finalize方法，且未被执行过，则将对象放置在F-Queue队列中，稍后GC会对该队列进行第二次标记并执行finalize方法，在finalize方法中没有将自身引用赋值给其他变量，则回收。</p>
<h4 id="垃圾收集器">垃圾收集器</h4>
<ol>
<li>Serial收集器</li>
</ol>
<p>单线程收集器，工作在新生代，进行垃圾收集时，必须暂停其他线程，在新生代采取复制算法<br>
2. ParNew收集器</p>
<p>Serial收集器的多线程版本，该收集器多个GC线程并行执行，但同样需要暂停用户线程，能与CMS收集器配合各工作，因CMS只能和ParNew或者Serial收集器配合工作，所以该收集器时Server模式首选收集器。</p>
<ol start="3">
<li>Parallel Scavenge收集器</li>
</ol>
<p>新生代收集器，采用复制算法，该收集器的特点是吞吐量可控制，即CPU用户线程运行的时间与总时间的比值</p>
<ol start="4">
<li>Serial Old收集器</li>
</ol>
<p>Serial收集器的老年代版本，采用标记整理算法，主要给client模式下的虚拟机使用，单线程。</p>
<ol start="5">
<li>Parallel Old收集器</li>
</ol>
<p>Parallel Scavenge收集器的老年代版本，采用标记整理算法，多线程</p>
<ol start="6">
<li>CMS收集器</li>
</ol>
<p>工作在老年代，以获取最短回收停顿时间为目标的收集器，响应速度快，用户体验好。基于标记清除算法，分为四步：初始标记仅标记下GC Root直接关联的对象，需要暂停用户线程；并发标记不用暂停用户线程；重新标记修正并发标记时标记变动的那部分对象，需要暂停用户线程；最后时并发清除，不需要暂停用户线程。</p>
<ol start="7">
<li>G1收集器</li>
</ol>
<p>地表最强收集器，堆不再划分成新生代和老年代，而是一块块大小相等的内存区域，G1会根据小堆的垃圾占比进行有优先级的区域回收方式。G1收集器分为四个步骤；初始标记，并发标记，最终标记，筛选回收。初始标记仅标记GC Roots直接关联的对象，需停顿用户线程；并发标记与用户线程并发执行，对堆中对象进行可达性分析，找出存活对象；最终标记修正并行标记阶段标记产生变化的记录，可并行执行，但需停顿用户线程；筛选回收则清理不可用对象，可与用户线程并发执行，但一般停顿用户线程效率更高</p>
<hr>
<h4 id="minor-gc和full-gc的区别">Minor GC和Full GC的区别</h4>
<p>Minor GC发生在新生代，比较频繁，Full GC发生在老年代，速度慢。堆中内存不足会触发GC，要避免老年代的GC。</p>
<h4 id="对象进入老年代的时机">对象进入老年代的时机</h4>
<p>大对象直接进入老年代，所以大对象存活时间又短的容易触发Full GC；Minor GC时，survivor空间不足，对象因分配担保进入老年代；对象保存有年龄计数器，每进行一次Minor GC，年龄加一，到了阈值会进入老年代；动态年龄判定，在survivor空间中相同年龄所有对象大于survivor的一半，该年龄以上的对象进入老年代。</p>
<hr>
<h4 id="类加载的时机">类加载的时机</h4>
<ol>
<li>
<p>使用new关键字实例化时，读取或设置一个类的静态字段时（对于final修饰的类常量，在调用时并不会触发被调用类的初始化，因为该常量已被编译到调用类的常量池字节码中），调用一个类的静态方法时。</p>
</li>
<li>
<p>使用java.lang.reflect包的方法对类进行反射调用时，类未被初始化。</p>
</li>
<li>
<p>初始化一个类时，父类没有被初始化，需先初始化父类（接口不要求父接口已初始化，除非用到了父类接口）。</p>
</li>
<li>
<p>虚拟机启动时初始化mian方法主类。</p>
</li>
<li>
<p>使用动态语言支持时。</p>
</li>
</ol>
<p>除此之外，其他任何情况都不会触发类的初始化，如通过子类调用父类的静态字段，不会初始化子类。</p>
<hr>
<h4 id="类加载过程">类加载过程</h4>
<ol>
<li>加载</li>
</ol>
<p>将类加载进方法区，生成代表该类的class对象，作为方法区该类的各种数据入口。</p>
<ol start="2">
<li>验证</li>
</ol>
<p>验证字节流是否符合class文件规范，确保class文件的字节流符合当前虚拟机规范。</p>
<ol start="3">
<li>准备</li>
</ol>
<p>为类变量分配内存并设置类变量初始值，除final类型的变量，其余都赋值为零或null或false。</p>
<ol start="4">
<li>解析</li>
</ol>
<p>将符号引用替换为直接引用</p>
<ol start="5">
<li>初始化</li>
</ol>
<p>执行类中Java代码，将初始值替换为真实赋值。</p>
<p>注意：初始化时代码执行是从上往下执行的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的类变量，只能赋值（在准备阶段已经分配了内存），不能访问（还没有赋真值，访问的值是无效的，这就不安全了）。</p>
<p><strong>子类和父类初始化顺序：</strong></p>
<p>1，在类加载的时候执行父类的static代码块，并且只执行一次（因为类只加载一次）；</p>
<p>2，执行子类的static代码块，并且只执行一次（因为类只加载一次）；</p>
<p>3，执行父类的类成员初始化，并且是从上往下按出现顺序执行；</p>
<p>4，执行父类的构造函数；</p>
<p>5，执行子类的类成员初始化，并且是从上往下按出现顺序执行。</p>
<p>6，执行子类的构造函数。</p>
<hr>
<h4 id="双亲委派模型">双亲委派模型</h4>
<p>Java中类加载器可分为三类：</p>
<ol>
<li>启动类加载器</li>
</ol>
<p>使用c++语言实现，负责加载lib目录中的类库，无法被Java程序直接引用。</p>
<ol start="2">
<li>扩展类加载器</li>
</ol>
<p>使用Java实现，负责加载lib\ext目录中的类库，开发之可以直接使用。</p>
<ol start="3">
<li>应用程序类加载器</li>
</ol>
<p>由ClassLoader实现，负责加载用户类路径（classpath）上指定的类库，开发者可以直接使用。</p>
<p>双亲委派模型的工作过程：如果一个类收到了类加载的请求，会首先把这个请求委派给父类加载器（使用组合关系来复用父加载器的代码），因此所有的加载请求都委派到顶层的启动类加载器，只有父类加载器无法完成这个加载请求，子加载器才会尝试自己去加载，这样保证了object类在程序中都是同一个类，保证了程序的稳定。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://GroundhogDaily.github.io/post/hello-gridea</id>
        <link href="https://GroundhogDaily.github.io/post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>