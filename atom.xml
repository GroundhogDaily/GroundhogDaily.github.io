<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://GroundhogDaily.github.io</id>
    <title>笔记</title>
    <updated>2020-08-07T07:06:28.720Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://GroundhogDaily.github.io"/>
    <link rel="self" href="https://GroundhogDaily.github.io/atom.xml"/>
    <subtitle>没有伞的孩子要努力奔跑</subtitle>
    <logo>https://GroundhogDaily.github.io/images/avatar.png</logo>
    <icon>https://GroundhogDaily.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 笔记</rights>
    <entry>
        <title type="html"><![CDATA[redis]]></title>
        <id>https://GroundhogDaily.github.io/post/redis/</id>
        <link href="https://GroundhogDaily.github.io/post/redis/">
        </link>
        <updated>2020-08-07T07:04:03.000Z</updated>
        <content type="html"><![CDATA[<h3 id="redis入门">redis入门</h3>
<h4 id="数据结构">数据结构</h4>
<ul>
<li>
<p>字符串类型</p>
<pre><code>set key value
get key
incr key 当字符串是数字时递增，不是整数则报错
incrby key increment 增加指定的整数，不是整数则报错
decr key 递减，不是整数则报错
decrby key increment 减少指定的整数，不是整数则报错
incrbyfloat key increment 增加指定的双精度浮点数
append key value 值末尾追加value,键不存在则将键的值设为value，返回追加后的字符串长度
strlen key 返回值的长度
mget key [key...]获取多个值
mset key value[key value ...]设置多个键值
另外还有其他对位操作的命令
</code></pre>
</li>
<li>
<p>散列类型(hash)</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/GroundhogDaily/PicGo/image-20200807102214699.png" alt="image-20200807102214699" loading="lazy"></figure>
<pre><code>hset key field value 字段不存在时返回1(插入)，存在返回0(更新)
hget key field 
hmset key field value [field value...]
hmget key field [field...]
hgetall key
hexists key field 判断字段是否存在，存在返回1，不存在返回0
hsetnx key field value 不存在则赋值
hincrby key field increment 增加指定的值，散列类型没有hincr命令
hdel key field [field...] 删除指定的字段，返回删除的个数
hkeys key 获取字段名
hvals key 获取字段值
hlen key 获取字段数量
</code></pre>
</li>
<li>
<p>列表类型(list)</p>
<p>列表类型（list）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素， 或者获得列表的某一个片段。列表类型内部采用双向链表（double linked list）实现。</p>
<pre><code>lpush key value1[value2...] 向列表左边增加元素，返回增加元素后列表的长度。先添加value1,顺序添加
rpush key value[value...]
lpop key
rpop key
hlen key 键不存在返回0，时间复杂度为O(1)
lrange key start stop 返回索引从start到stop的元素，包含两端，起始为0.不删除元素。
    例：LRANGE key -2 -1 支持负索引，&quot;−1&quot;表示最右边第一个元素，&quot;-2&quot;表示最右边第二个元素，依次类推
    例：LRANGE key 0 -1  返回全部元素，
lren key count value 会删除列表中前count个值为value的元素，返回值是实际删除的元素个数。
    （1）当 count &gt; 0时 LREM 命令会从列表左边开始删除前 count 个值为 value的元素。
    （2）当 count &lt; 0时 LREM 命令会从列表右边开始删除前|count|个值为 value 的元素。
    （3）当 count = 0是 LREM命令会删除所有值为 value的元素。
lindex key index 获得指定索引的元素值
lset key index 设置指定索引的元素值
ltrim key start end 删除指定索引范围之外的所有元素
linsert key before/after pivot value 会在列表中从左到右查找值为 pivot 的元素，然后根据第二个参	数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面
rpoplpush source destination 将元素从一个列表转到另一个列表,：先执行RPOP命令再执行LPUSH命令。		RPOPLPUSH命令会先从source列表类型键的右边弹出一个元素，然后将其加入到destination列表类型键的		左边，并返回这个元素的值，整个过程是原子的。
</code></pre>
</li>
<li>
<p>集合类型(set)</p>
<p>在集合中的每个元素都是不同的，且没有顺序。一个集合类型（set）键可以存储至多232−1个字符串。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/GroundhogDaily/PicGo/image-20200807112342858.png" alt="image-20200807112342858" loading="lazy"></figure>
<pre><code>sadd key member [member...] 返回加入的元素个数，已存在的元素不添加
srem key member [member...] 删除，返回删除的个数
smembers key 返回集合中所有的元素
sismember key member 判断元素是否在集合中，存在返回1，不存在返回0，个时间复杂度为O(1)
sdiff key1 [key...] 差集，返回所有属于key1,不属于其他key的元素
sinter key [key] 交集，返回每个key都包含的元素，不重复
sunion key [key] 并集，返回所有key的元素，不重复
scard key 获取集合中元素个数
sdiffstore destination key1 [key...] SDIFFSTORE命令和SDIFF命令功能一样，唯一的区别就是前者不会直接	返回运算结果，而是将结果存储在destination键中。
sinterstore destination key [key] 
sunionstore destination key [key]
srandmember key [count] 随机获取一个或多个元素
    （1）当count为正数时，SRANDMEMBER会随机从集合里获得count个不重复的元素。如果count的值大于集合 		中的元素个数，则SRANDMEMBER会返回集合中的全部元素。
    （2）当count为负数时，SRANDMEMBER会随机从集合里获得|count|个的元素，这些元素有可能相同
spop key 从集合中随机弹出一个元素
</code></pre>
</li>
<li>
<p>有序集合类型(sorted set)</p>
<p>在集合类型的基础上有序集合类型为集合中的每个元素都关联了一个分数，这使得我们 不仅可以完成插入、删除和判断元素是否存在等集合类型支持的操作，还能够获得分数最高 （或最低）的前N个元素、获得指定分数范围内的元素等与分数有关的操作。虽然集合中每 个元素都是不同的，但是它们的分数却可以相同。</p>
<pre><code>zadd key score member [score member]如果该元素已经存在则会用新的分数替换原有的分数
zrange key start stop [withscore] 按照元素分数从小到大的顺序返回索引从 start到		stop之间的所有元素（包含两端的元素）,ZRANGE命令与LRANGE命令十分相似，如索引都是从	 0开始，负数代表从后向前查找（−1表示最后一个元素）。如果需要同时获得元素的分数的话可	以在 ZRANGE命令的尾部加上 WITHSCORES 参数,的时间复杂度为O(log n+m)
zrangebyscore key min max[withscores] [limit offset count]该命令按照元素分数		从小到大的顺序返回分数在min和max之间（包含min和max）的元素,如果希望分数范围不包含		端点值，可以在分数前加上“(”符号。min和max还支持无穷大，同ZADD命令一样，-inf和		+inf分别表示负无穷和正无穷。在本命令中 LIMIT offset count与 SQL 中的用法基本相	 同，即在获得的元素列表的基础上向后偏移offset个元素，并且只获取前count个元素。
zincrby key increment member 增加某个元素的分数，返回更改后的分数
zcard key 获得集合中元素的数量
zcount key min max 获得指定分数范围内的元素个数
zrem key member [member] 删除一个或多个元素，返回成功删除的元素数量
zremrangebyrank key start stop 按照元素分数从小到大的顺序，删除指定排名范围内的元	素，返回删除的元素数量
zremrangebyscore key min max 删除指定分数范围内的元素，并返回删除的元素数量
zrank key member 按照元素分数从小到大的顺序获得指定的元素member的排名
zrevrank key member 按照元素分数从大到小的顺序获得指定的元素member的排名
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java并发中级主题]]></title>
        <id>https://GroundhogDaily.github.io/post/java-bing-fa-zhong-ji-zhu-ti/</id>
        <link href="https://GroundhogDaily.github.io/post/java-bing-fa-zhong-ji-zhu-ti/">
        </link>
        <updated>2019-12-17T06:26:24.000Z</updated>
        <content type="html"><![CDATA[<h4 id="同步工具类">同步工具类</h4>
<ul>
<li>
<p>ConcurrentHashMap</p>
<p>ConcurrentHashMap使用粒度更细的分段所来实现更大程度的共享，ConcurrentHashMap的实现中使用了一个包含16个锁的数组，每个锁保护所有散列桶的1/16，其中第N个散列桶由第（N mod 16）个锁来保护，好处是可以实现更高的并发性，但如果执行的操作需要加锁整个容器时，代价也会很大。</p>
<p>ConcurrentHashMap与其他并发容器一起增强了 同步容器类：它们提供的迭代器不会抛出ConcurrentModificationException（<strong>大多数情况下，使用迭代器对容器进行迭代时，如果有其他线程修改了容器，hasNext和next会抛出异常</strong>）,因此不需要在迭代过程中对容器加锁。即它返回的迭代器具有弱一致性，允许并发的修改。</p>
<p>因分段锁的特性，对于一些需要在整个Map上进行计算的方法，如size和isEmpty，这些方法的语义被略微减弱了，即返回的值是一个估计值而不是精确值，因为并没有同步。</p>
<p>在ConcurrentHashMap中没有实现对Map加锁以提供独占访问，即获得Map的锁并不能阻止其他线程访问该Map。</p>
<p>不允许将null作为键和值。</p>
<p>相比于hashmap，ConcurrentHashMap多了额外的一些原子操作方法（都继承子AbstractMap）。</p>
<pre><code class="language-Java">V putIfAbsent(K key,V value) //仅当k没有相应的映射值时才插入
boolean remove(Object key,Object value)//仅当k被映射到v时才移除
V replace(K key,V newValue)//仅当k被映射到某个值时才替换为newValue
boolean replace(K key,V oldValue,V newValue)//仅当k被映射到oldValue时才替换为newValue
</code></pre>
</li>
<li>
<p>BlockingQueue</p>
<p>阻塞队列提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。</p>
<p>BlockingQueue不接受null元素。</p>
<p>BlockingQueue 实现主要用于生产者-使用者队列。</p>
<pre><code class="language-Java">boolean add(E e)//添加元素，成功返回true，如果空间不足抛出IllegalStateException
</code></pre>
<pre><code class="language-Java">boolean offer(E e)//添加元素，成功返回true，空间不足返回false，当队列有容量限制时优先使用此方法
</code></pre>
<pre><code class="language-Java">void put(E e) throws InterruptedException//添加元素，空间不足则阻塞直到添加成功，可被中断（当前线程被中断）
</code></pre>
<pre><code class="language-Java">boolean offer(E e,long timeout,TimeUnit unit) throws InterruptedException
//添加元素，在指定的时间内阻塞等待可用空间，可被中断
</code></pre>
<pre><code class="language-java">E take() throws InterruptedException//获取并移除队列的头部，如没有元素则阻塞，可被中断
</code></pre>
<pre><code class="language-Java">E poll(long timeout,TimeUnit unit) throws InterruptedException
//获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。 
</code></pre>
<p>综上，BlockingQueue提供了四种添加元素的方式，可以根据业务需求选择合适的方法。BlockingQueue共有六种实现，下面提供了个人的介绍和理解。</p>
<p><strong>ArrayBlockingQueue</strong>:一个由数组支持的有界阻塞队列。此队列按  FIFO（先进先出）原则对元素进行排序。队列的<em>头部</em> 是在队列中存在时间最长的元素。队列的<em>尾部</em>  是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。 可指定线程的访问策略，设置为true则按FIFO顺序访问线程（公平锁），默认false。此类及其迭代器实现了 Collection和 Iterator 接口的所有<em>可选</em> 方法，可以返回弱一致性的迭代器。</p>
<p>ArrayBlockingQueue底层使用lock锁，生产者添加元素和消费者取出元素都是同一个锁。</p>
<p><strong>LinkedBlockingQueue</strong>：一个基于已链接节点的、范围任意的 blocking queue。此队列按  FIFO（先进先出）排序元素。队列的<em>头部</em> 是在队列中时间最长的元素。队列的<em>尾部</em>  是在队列中时间最短的元素。新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。默认容量等于Integer.MAX_VALUE，可指定容量大小。此类及其迭代器实现了 Collection和 Iterator 接口的所有<em>可选</em> 方法，可以返回弱一致性的迭代器。</p>
<p>LinkedBlockingQueue在消费者和生产者方法中使用不同的lock锁，消费者和生产者可以并行运行。</p>
<p><strong>PriorityBlockingQueue</strong>：一个无界阻塞队列，构造函数需指定初始容量。基于优先级的队列，线程获取锁的方式按照FIFO的顺序。另外，该队列不阻塞数据生产者，容量不足会一直扩容，直到OutOfMemoryError，但会阻塞数据消费者。生产者和消费者公用一个lock锁。底层使用数组。</p>
<p><strong>DelayQueue</strong>：一个无界阻塞队列，只有在延迟期满时才能从中提取元素（存储的元素继承自Dalayed）</p>
<p>。该队列插入数据不会阻塞，获取数据时有可能阻塞。生产者和消费者共用一个lock锁。</p>
<p><strong>SynchronousQueue</strong> ：每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。不能在同步队列上进行  <code>peek</code>，因为仅在试图要移除元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没有元素可用于迭代。</p>
</li>
<li>
<p>闭锁（CountDownLatch)</p>
<p>一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</p>
<p>该类需要在构造函数指定计数器的初始值，countDown方法会将计数器减一，而await方法则阻塞直到计数器的值为零。await方法可指定阻塞时间。可被中断。</p>
<p>用法：</p>
<ol>
<li>确保某个计算在其需要的所有资源都被初始化后才继续执行</li>
<li>确保某个服务在其依赖的所有服务都已经启动后才启动</li>
<li>等待直到某个操作的所有参与者都就绪再继续执行</li>
</ol>
</li>
<li>
<p>Callable</p>
<p>与runnable类似，不同的是，Callable可返回结果，而runnable不能。Callable通常与FutureTask一起使用，执行可返回结果的计算。</p>
</li>
<li>
<p>FutureTask</p>
<p>可取消的异步计算。<s>利用开始和取消计算的方法、查询计算是否完成的方法和获取计算结果的方法，此类提供了对 Future 的基本实现仅在计算完成时才能获取结果；如果计算尚未完成，则阻塞 <code>get</code> 方法。</s>（屁话，看不懂）。就是相比于runnable，FutureTask通过Callable实现了可以获得结果的run方法，而get方法在获得结果（run方法执行完）前会一直阻塞。一旦计算完成，就不能再重新开始或取消计算。</p>
<p>可使用 <code>FutureTask</code> 包装 Callable'或  Runnable（返回null）对象。因为  <code>FutureTask</code> 实现了 <code>Runnable</code>，所以可将 <code>FutureTask</code> 提交给 Executor 执行。</p>
<p>使用场景：</p>
<ol>
<li>
<p>Future用于异步获取执行结果或者取消任务。</p>
</li>
<li>
<p>在高并发场景下确保任务只执行一次。</p>
</li>
</ol>
<pre><code class="language-java">//简单使用方式，在run方法执行完之前get方法处于阻塞状态
private final FutureTask&lt;V&gt; future = new FutureTask(new Callable&lt;V&gt;(){
    public V call() {
        do something ...
        return v;
    }
});
//future实现了runnable接口，可以交给thread和executor异步执行
private final Thread thread = new Thread(future);
thread.start();

ExecutorService executor = Executors.newCachedThreadPool();
executor.submit(future);

future.get();//这里要注意异常的处理，Callable抛出的异常会被封装成ExecutionException，然后从此抛出，应该要有具体对某类异常的处理方式
</code></pre>
<pre><code class="language-Java">V get() throws InterruptedException, ExecutionException//阻塞直到返回结果，可中断，也可以设置阻塞时间
boolean cancel(boolean mayInterruptIfRunning)//取消任务的执行，具体详见文档
</code></pre>
</li>
<li>
<p>计数信号量（Counting Semaphore）</p>
<p>信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 <code>acquire()</code>，然后再获取该许可。每个  <code>release()</code> 添加一个许可，从而可能释放一个正在阻塞的获取者。</p>
<p>计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。</p>
<p>计数信号量还可以用来实现某种资源池，或者对容器施加边界（将任何一种容器变成有界阻塞容器）。</p>
<p>许可需要在创建信号量时指定，也可指定线程阻塞后获得许可的策略，默认非公平，设置为ture则按FIFO顺序。</p>
<p>Semaphore类主要有4类方法，都可以指定要获取（释放）的许可数量（方法重载）：</p>
<pre><code class="language-java">void acquire() throws InterruptedException
</code></pre>
<p>从此信号量获取一个许可，没有可用许可则阻塞，直到获得许可或当前线程被中断。</p>
<pre><code class="language-Java">void acquireUninterruptibly()
</code></pre>
<p>从此信号量获取一个许可，没有可用许可则阻塞，忽略中断，并在获得许可后设置中断状态。</p>
<pre><code class="language-java">void release()
</code></pre>
<p>释放一个许可，将其返回给信号量。 这里注意，<strong>一个线程释放前，并不需要先获得许可</strong>。</p>
<pre><code class="language-Java">boolean tryAcquire()
</code></pre>
<p>获取一个许可（如果提供了一个）并立即返回，其值为 true，将可用的许可数减 1。 如果没有可用的许可，则此方法立即返回并且值为 false。也可在指定时间内等待许可，超时返回false。</p>
</li>
<li>
<p>栅栏（CyclicBarrier）</p>
<p>栅栏类似与闭锁，它能阻塞一组线程直到某个事件发生，栅栏在释放后可以重用。</p>
<p>简单来说构造方法指定要到达栅栏位置的线程数量N，而线程调用栅栏的await()方法阻塞，直到N个线程都执行到await方法，才允许继续执行。</p>
<p><code>CyclicBarrier</code> 支持一个可选的 <code>Runnable</code> 命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次。即所有线程到达await方法后，执行该命令（由任意一个子线程执行一次）。</p>
<pre><code class="language-java">//用法
public class CycliBarrierTest{
    private final CyclicBarrier barrier;
    private final Worker[] workers;
    
    public CycliBarrierTest(int size){
        this.barrier = new CyclicBarrier(size,new Runnable(){//可选参数Runnable
            public void run(){
                do something ...//在全部线程执行到await方法后要执行的语句，只执行一次
            }
        })；
        this.workers = new Worker[size];
    }
    
    private class Worker implemnets Runnable{
        public void run(){
            do something ...
            try{
                barrier.await();
            } catch(InterruptedException e){
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
               e.printStackTrace();
            }
            do something ...
        }
    }
    
    public void start(){
        for(int i=0;i &lt; workers.length;i++){
            new Thread(workers[i]).start();
        }
    }
}
</code></pre>
</li>
<li>
<p>闭锁和栅栏的区别：</p>
<p>闭锁用于指定某些操作的开始时机，等待计数器为零才开始执行（一个服务执行完，计数器减一）。</p>
<p>栅栏用于等待一组线程都执行到某个位置后才继续执行。</p>
<p>栅栏指定等待的线程并不会执行完释放资源，即这些线程会因调用await方法阻塞。闭锁则利用计数器递减的方式，每个线程调用countdown方法并不会阻塞，线程有可能已经运行完成并且释放资源，而调用await方法的线程则等待计数器为零。</p>
</li>
<li>
<p>Executor</p>
<p>执行已提交的 <code>Runnable</code> 任务的对象。此接口提供一种将任务提交与每个任务将如何运行的机制（包括线程使用的细节、调度等）分离开来的方法。</p>
</li>
<li>
<p>Executors</p>
<p>创建线程池的工具类，可以通过调用Executors中的静态工厂方法来创建线程池。</p>
<pre><code class="language-java">static ExecutorService newFixedThreadPool(int nThreads)
</code></pre>
<p>创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量。</p>
<pre><code class="language-java">static ExecutorService newCachedThreadPool()
</code></pre>
<p>创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。</p>
<pre><code class="language-java">static ExecutorService newSingleThreadExecutor()
</code></pre>
<p>单线程的Executor，他创建单个工作者线程来执行任务，如果线程异常结束，会创建另一个线程来代替。它能确保依照任务在队列中的顺序来执行。</p>
<pre><code class="language-java">static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
</code></pre>
<p>创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务。Timer类负责管理延迟任务，但存在缺陷。Timer在执行所有定时任务时只会创建一个线程，如果某个任务的执行时间过长，那么将破坏其他TimerTask的定时精确性，例如某个周期任务需要每10ms执行一次，另一个TimerTask需要执行40ms，那么这个周期任务便不能得到需要的效果。</p>
</li>
<li>
<p>ExecutorService</p>
<p>ExecutorService扩展了Executor接口，增加了生命周期管理的方法以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。</p>
<pre><code class="language-java">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)
</code></pre>
<p>提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。该 Future 的 get 方法在成功完成时将会返回该任务的结果。</p>
<pre><code class="language-java">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)
</code></pre>
<p>提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功完成时将会返回给定的结果。</p>
<pre><code class="language-java">Future&lt;?&gt; submit(Runnable task)
</code></pre>
<p>提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功 完成时将会返回 null。</p>
<pre><code class="language-java">boolean isShutdown()
</code></pre>
<p>如果此执行程序已关闭，则返回 true。</p>
<pre><code class="language-java">void shutdown()
</code></pre>
<p>启动一次顺序关闭，执行以前提交的任务，但不接受新任务。如果已经关闭，则调用没有其他作用。</p>
<pre><code class="language-java">List&lt;Runnable&gt; shutdownNow()
</code></pre>
<p>试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。<br>
无法保证能够停止正在处理的活动执行任务，但是会尽力尝试。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java多线程基础]]></title>
        <id>https://GroundhogDaily.github.io/post/java-duo-xian-cheng-ji-chu/</id>
        <link href="https://GroundhogDaily.github.io/post/java-duo-xian-cheng-ji-chu/">
        </link>
        <updated>2019-11-16T01:28:57.000Z</updated>
        <content type="html"><![CDATA[<h4 id="使用多线程的方法">使用多线程的方法</h4>
<p>继承Thread类</p>
<p>实现runnable接口</p>
<h4 id="线程常用方法thread类和object类">线程常用方法(Thread类和Object类)</h4>
<p>这些方法要注意当前线程和该线程表述，当前线程即正在执行该代码段的线程，该线程指调用该方法的那个线程。</p>
<p>一般静态Thread方法调用是调用当前正在执行的线程，直接通过类名调用即可。</p>
<pre><code class="language-java">static Thread currentThread();
Thread.currentThread().getName()
</code></pre>
<p>返回当前正在执行的线程名，currentThread()是返回当前正在执行的线程。</p>
<pre><code class="language-java">boolean isAlive()
</code></pre>
<p>判断该线程是否是否处于活跃状态，即正在运行或准备运行的状态。</p>
<pre><code class="language-java">static void sleep(long millis)
</code></pre>
<p>在指定的毫秒数内让当前正在执行的线程休眠，该方法不会让线程释放锁。</p>
<pre><code class="language-java">long getId()
</code></pre>
<p>返回该线程的标识符，线程ID唯一不变，线程终止时，该线程ID可以被重新使用。</p>
<pre><code class="language-java">void interrupt()
</code></pre>
<p>中断线程，该方法不会使正在运行的线程停止，只是改变中断标志，而对于改变了中断标志的线程，调用wait，sleep，join方法时会抛出异常。如果线程在调用 Object 类的 wait()、wait(long) 或 wait(long, int) 方法，或者该类的 join()、join(long)、join(long, int)、sleep(long) 或 sleep(long, int) 方法过程中受阻，则其中断状态将被清除，它还将收到一个 InterruptedException。</p>
<p>该方法主要作用是让处于wait，sleep，join状态的线程退出，让线程提早结束。但会抛出异常（中断状态也会被清除），后面的语句也不再执行，如果有需要，可以在catch语句块中编写要执行的代码。</p>
<pre><code class="language-java">static boolean interrupted()
</code></pre>
<p>判断当前正在执行的线程是否处于中断状态，并清除中断状态，可以与interrupt方法一起使用使线程停止（抛出异常的方式或return）。</p>
<p>interrupt方法可以在其他地方通过线程引用调用设置中断，在该线程执行时即可判断是否中断并作出响应。</p>
<pre><code class="language-java">boolean isInterrupted()
</code></pre>
<p>测试线程是否已经中断，不改变中断状态。</p>
<pre><code class="language-java">static void yield()
</code></pre>
<p>暂停当前正在执行的线程对象，并执行其他线程。即让出cpu资源，并处于就绪状态等待cpu资源。</p>
<pre><code class="language-java">final void setPriority(int newPriority)
</code></pre>
<p>更改线程的优先级（1-10）。</p>
<p>在Java中，线程优先级具有继承性，比如A线程启动B线程，则B线程的优先级与A是一样的。</p>
<pre><code class="language-java">final int getPriority()
</code></pre>
<p>返回线程的优先级。</p>
<pre><code class="language-java">final void join()
</code></pre>
<p>等待该线程终止，并释放锁。</p>
<pre><code class="language-java">final wait void wait()
</code></pre>
<p>Object方法，使线程等待，将线程加入“预执行队列”中，并释放锁，只能在同步语句块中使用。</p>
<p>为防止出现通知过早等问题，该方法需要在循环中使用，一般用while语句加上标识符。</p>
<pre><code class="language-java">final void notify()
</code></pre>
<p>Object方法，唤醒在此对象监视器上等待的单个线程（随机唤醒一个），被唤醒的线程加入就绪队列，等待当前线程释放锁，必须在同步语句块中使用，</p>
<pre><code class="language-java">final void notifyAll()
</code></pre>
<p>Object方法，唤醒在此对象监视器上等待的所有线程，必须在同步语句块中使用。</p>
<p>上述三个方法可以实现线程间通信的功能，生产者与消费者则需用到notifyAll唤醒所有等待的线程，否则会产生循环等待的问题，即生产者唤醒生产者，消费者唤醒消费者。</p>
<h4 id="生产者和消费者模型">生产者和消费者模型</h4>
<pre><code class="language-java">/*
简述：由生产者和消费者共同维护一个缓冲区，生产者负责向缓冲区添加消息，消费者从缓冲区消费消息，生产者和消费者线程通过缓冲区进行单向通信。
使用wait/notifyAll实现的模型，同一时间只有一个线程操作缓冲区（wait/notifyAll都要在同步块中使用），这里唤醒和等待都要基于同一个锁对象才有意义。
*/
class Person{
	private int foodNum = 0;//缓冲区
    private Object synObj = new Object();//锁对象
    Private final int MAX_NUM = 10;//缓冲区大小
    
    在wait时中断抛出异常
    public void produce() throws InterruptedException{
        synchronized(synObj){
            //这里必须用while，如果出现生产者唤醒生产者这种情况，则继续等待，下面consume同理
            while(foodNum == MAX_NUM){
                synObj.wait();
            }
            foodNum ++;//生产消息
            synObj.notifyAll();//唤醒所有线程，也必须使用该方法唤醒所有等待线程
        }
    }
    
    public void consume() throws InterruptedException{
        synchronized(synObj){
            while(foodNum == 0){
                synObj.wait();
            }
            foodNum--;//消费消息
            synObj.notifyAll();
        }
    }	
}

class Producer implements Runnable{
	Person person ;
    
    public Producer(Person person){
        this.person = person;
    }
    
    public void run(){
        while(true){//根据具体业务而定
            //发生中断时会抛出异常，提前结束等待（调用interrupt方法，中断当前线程），所以需要     		   
            //在出现这种情况时进行相应的处理，有时候业务需要提前结束等待。
            try{
            	person.produce();
        	}catch(InterruptedException e){
            	e.printStackTrace();
       		}
        }
    }
}

class Consumer implements Runnable{
    Person person;
    
    public Consumer(Person person){
        this.person = person;
    }
    
    public void run(){
        while(true){
            try{
            	person.consume();
        	}catch(InterruptedException e){
            	e.printStackTrace();
       		}
        }
    }
}
</code></pre>
<h4 id="通过管道进行线程间通信">通过管道进行线程间通信</h4>
<pre><code class="language-Java">PipedInputStream（从输入流中读取数据） PipedOutputStream //字节流
PipedReader PipedWriter //字符流
//四个类都有connect方法，用于相互连接，一个线程通过PipedOutputStream或PipedWriter向流输入数据，另一个线程取数据
//管道输入流包含一个缓冲区，可在缓冲区限定的范围内将读操作和写操作分离开。
</code></pre>
<h4 id="lock的使用显式锁">Lock的使用(显式锁)</h4>
<h5 id="reentrantlock">ReentrantLock</h5>
<pre><code class="language-Java">/*
ReentrantLock:一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。 
*/
//典型代码
public class Demo{
    private final Lock lock = new ReentrantLock();
    public void test(){
        lock.lock();
        //lock获取锁后运行代码，当抛出异常时不像synchronized一样，自动释放锁，所以需要try语句保证最后能释放锁，不然会有死锁的可能。
        try{
            //do something ...
        }finally{
            lock.unlock();
        }
    }
}
</code></pre>
<h4 id="与lock关联的condition">与Lock关联的Condition</h4>
<p>理解：conditon通过lock.newCondition()创建，实现了粒度更细的等待/通知模型。一个Lock对象可以创建多个Condition,而一个Condition可以和多个线程关联，实现了范围性的等待/通知。</p>
<p>线程执行到condition.await()时等待并释放锁，另一个线程通过condition.signal()/condition.signalAll()唤醒同一个condition内等待的线程。一个condition即为一个条件队列，通过调用不同的condition即可唤醒不同的条件队列等待的线程。</p>
<pre><code class="language-java">public class demo{
	private final Lock lock = new ReetrantLock();
    private Condition conditon1 = lock.newConditon();
    private Condition condition2 = lock.newConditon();
    
    public void await1(){
        lock.lock();
        try{
            do something ...
            condition1.await();
            do something ...
        }catch(InterruptedException e){
            e.prinStackTrace();
        }finally{
            lock.unlock();
        }
    }
    
    public void await2(){
        lock.lock();
        try{
            do something ...
            condition12.await();
            do something ...
        }catch(InterruptedException e){
            e.prinStackTrace();
        }finally{
            lock.unlock();
        }
    }
    
    public void signal1(){
        lock.lock();
        try{
            do something ...
            condition11.signalAll();
            do something ...
        }finally{
            lock.unlock();
        }
    }
    
     public void signal2(){
        lock.lock();
        try{
            do something ...
            condition12.signalAll();
            do something ...
        }finally{
            lock.unlock();
        }
    }
}
</code></pre>
<h5 id="公平锁和非公平锁">公平锁和非公平锁</h5>
<p>锁Lock分为“公平锁”和“非公平锁”，公平锁表示线程获取锁的顺序是按照FIFO先进先出的顺序，非公平锁则是一种获取锁的抢占机制，随机获取锁。</p>
<pre><code class="language-java">lock = new ReentrantLock(true)//设为公平锁，默认为false
</code></pre>
<h5 id="有条件的执行线程">有条件的执行线程</h5>
<pre><code class="language-java"> boolean tryLock()
</code></pre>
<p>仅在调用时锁未被另一个线程保持的情况下，才获取该锁。 如果锁被另一个线程保持，则此方法将立即返回 false 值。 与lock()不同的是，他不会等待获取锁，而是直接返回false。</p>
<pre><code class="language-java">boolean tryLock(long timeout,TimeUnit unit) throws InterruptedException
</code></pre>
<p>如果锁在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁。</p>
<p>因为此方法是一个显式中断点，所以要优先考虑响应中断，而不是响应锁的普通获取或重入获取，或者报告所用的等待时间。</p>
<p>理解：lock锁可实现有条件，有时间限制的获取锁，在中断情况下放弃执行后面的同步代码块，并抛出异常，在实现时可通过设置中断有条件的让一个线程是否执行同步代码。</p>
<h5 id="conditon部分方法">Conditon部分方法</h5>
<pre><code class="language-java">void awaitUninterruptibly()	
</code></pre>
<p>造成当前线程在接到信号之前一直处于等待状态。被中断后不抛出异常，继续执行。</p>
<p>这里注意，await()方法在中断时会抛出异常，而此方法中断相当于唤醒当前线程的信号，即在中断，signal()，signalAll()唤醒当前线程前一直处于等待状态。</p>
<pre><code class="language-Java">boolean awaitUntil(Date deadline) throws InterruptedException
</code></pre>
<p>造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。 中断后抛出异常。</p>
<h5 id="reentrantreadwritelock">ReentrantReadWriteLock</h5>
<p>读写锁，与ReentrantLock不同的是，读写锁表示有两个锁，一个是读操作相关的锁，另一个是写相关操作的锁。多个读锁之间不互斥，读锁与写锁互斥，写锁和写锁互斥</p>
<p>在某些不需要操作实例变量的方法中，可以使用读锁提高运行速度。</p>
<pre><code>lock.readLock().lock();//获得读锁
lock.readLock().unlock();//释放读锁
lock.writeLock.lock();//获得写锁
lock.writeLock().unlock();//释放读锁
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java虚拟机]]></title>
        <id>https://GroundhogDaily.github.io/post/java-xu-ni-ji/</id>
        <link href="https://GroundhogDaily.github.io/post/java-xu-ni-ji/">
        </link>
        <updated>2019-11-10T08:40:06.000Z</updated>
        <content type="html"><![CDATA[<h4 id="虚拟机内存划分">虚拟机内存划分</h4>
<ol>
<li>程序计数器</li>
</ol>
<p>计数器记录了正在执行的虚拟机字节码指令的地址，如果执行的是native方法，计数器值为空</p>
<ol start="2">
<li>Java虚拟机栈</li>
</ol>
<p>虚拟机栈描述的是Java方法执行的内存模型，每一个方法从调用到执行完成的过程，对应着一个栈帧在虚拟机中入栈到出栈的过程虚拟机栈不可以动态扩展时，如果线程请求的栈深度大于虚拟机所允许的深度，会抛出StackOverflowError异常。虚拟机栈动态扩展时，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<ol start="3">
<li>本地方法栈</li>
</ol>
<p>与虚拟机栈相似，不过对应的是native方法服务，同样会抛出上述异常。</p>
<ol start="4">
<li>Java堆</li>
</ol>
<p>存放对象实例，逻辑上是连续的，物理上 不一定连续，可通过-Xmx和-Xms扩展</p>
<ol start="5">
<li>方法区</li>
</ol>
<p>用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。</p>
<ol start="6">
<li>运行时常量池</li>
</ol>
<p>用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法去的运行时常量池中存放，以及string常量，常用于intern方法（当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（用 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并返回此 String 对象的引用。）</p>
<hr>
<h4 id="对象的创建过程p45">对象的创建过程（p45）</h4>
<p>虚拟机遇到一个new指令后，首先检查该指令参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载，解析初始化，如果没有则执行类加载过程。</p>
<h5 id="对象的访问定位java程序需要通过栈上的reference数据来操作堆上的具体对象">对象的访问定位（Java程序需要通过栈上的reference数据来操作堆上的具体对象）</h5>
<ol>
<li>句柄方式</li>
</ol>
<p>Java堆中会划分出一块内存来作为句柄池，reference中存储了对象的句柄地址，而句柄包含了对象的具体地址。</p>
<ol start="2">
<li>直接指针访问</li>
</ol>
<p>Reference中存储了对象的的真实地址</p>
<p>优劣：对象被移动只会改变句柄钟到实例数据指针，reference不需要修改，直接指针速度快。</p>
<hr>
<h4 id="垃圾回收算法">垃圾回收算法</h4>
<ol>
<li>引用计数算法</li>
</ol>
<p>对象保存一个引用计数器，每当有一个地方引用它时，计数器值加一，引用是失效时则减一，为0则不在被使用，缺点是难以解决循环引用的问题。</p>
<ol start="2">
<li>可达性分析算法</li>
</ol>
<p>通过称为“GC root”的对象为起始点，从这些起始点向下搜索，当一个对象到GC root 没有任何引用链相连，则这个对象是不可达的，在枚举根节点分析时保证对象引用关系不变化，所以会造成停顿。</p>
<p>GC root对象：</p>
<p>a.  虚拟机栈中引用的对象</p>
<p>b.  方法区中静态变量属性引用的对象</p>
<p>c.  方法区中常量引用的对象</p>
<p>d.  本地方法栈中引用的对象</p>
<ol start="3">
<li>标记清除算法</li>
</ol>
<p>标记完后续统一回收，但标记清除效率不高，会产生大量不连续的内存碎片，该算法是GC的基础。</p>
<ol start="4">
<li>复制算法</li>
</ol>
<p>Java中将堆分为新生代和老年代，新生代又分为Eden和两个servivor空间，每次将存活对象复制到另一个servivor中，如果servivor空间不足，则由老年代进行分配担保，存储这些对象。</p>
<ol start="5">
<li>标记整理算法</li>
</ol>
<p>该算法工作在老年代，在标记后将存活对象向一端移动，清理另一边的内存，以应对对象存活率较高的情况。</p>
<ol start="6">
<li>分代收集算法</li>
</ol>
<p>即将堆分为新生代和老年代，再在不同代的堆运行不同的算法，新生代采用复制算法，老年代使用标记清除或者标记整理算法。</p>
<hr>
<h4 id="对象回收过程">对象回收过程</h4>
<p>首先进行可达性分析，这里会造成GC停顿，停顿指的是线程执行到安全点停顿，如果对象不可达，则开始第一次标记筛选，筛选条件是是否有必要执行finalize方法，如果覆盖了finalize方法，且未被执行过，则将对象放置在F-Queue队列中，稍后GC会对该队列进行第二次标记并执行finalize方法，在finalize方法中没有将自身引用赋值给其他变量，则回收。</p>
<h4 id="垃圾收集器">垃圾收集器</h4>
<ol>
<li>Serial收集器</li>
</ol>
<p>单线程收集器，工作在新生代，进行垃圾收集时，必须暂停其他线程，在新生代采取复制算法<br>
2. ParNew收集器</p>
<p>Serial收集器的多线程版本，该收集器多个GC线程并行执行，但同样需要暂停用户线程，能与CMS收集器配合各工作，因CMS只能和ParNew或者Serial收集器配合工作，所以该收集器时Server模式首选收集器。</p>
<ol start="3">
<li>Parallel Scavenge收集器</li>
</ol>
<p>新生代收集器，采用复制算法，该收集器的特点是吞吐量可控制，即CPU用户线程运行的时间与总时间的比值</p>
<ol start="4">
<li>Serial Old收集器</li>
</ol>
<p>Serial收集器的老年代版本，采用标记整理算法，主要给client模式下的虚拟机使用，单线程。</p>
<ol start="5">
<li>Parallel Old收集器</li>
</ol>
<p>Parallel Scavenge收集器的老年代版本，采用标记整理算法，多线程</p>
<ol start="6">
<li>CMS收集器</li>
</ol>
<p>工作在老年代，以获取最短回收停顿时间为目标的收集器，响应速度快，用户体验好。基于标记清除算法，分为四步：初始标记仅标记下GC Root直接关联的对象，需要暂停用户线程；并发标记不用暂停用户线程；重新标记修正并发标记时标记变动的那部分对象，需要暂停用户线程；最后时并发清除，不需要暂停用户线程。</p>
<ol start="7">
<li>G1收集器</li>
</ol>
<p>地表最强收集器，堆不再划分成新生代和老年代，而是一块块大小相等的内存区域，G1会根据小堆的垃圾占比进行有优先级的区域回收方式。G1收集器分为四个步骤；初始标记，并发标记，最终标记，筛选回收。初始标记仅标记GC Roots直接关联的对象，需停顿用户线程；并发标记与用户线程并发执行，对堆中对象进行可达性分析，找出存活对象；最终标记修正并行标记阶段标记产生变化的记录，可并行执行，但需停顿用户线程；筛选回收则清理不可用对象，可与用户线程并发执行，但一般停顿用户线程效率更高</p>
<hr>
<h4 id="minor-gc和full-gc的区别">Minor GC和Full GC的区别</h4>
<p>Minor GC发生在新生代，比较频繁，Full GC发生在老年代，速度慢。堆中内存不足会触发GC，要避免老年代的GC。</p>
<h4 id="对象进入老年代的时机">对象进入老年代的时机</h4>
<p>大对象直接进入老年代，所以大对象存活时间又短的容易触发Full GC；Minor GC时，survivor空间不足，对象因分配担保进入老年代；对象保存有年龄计数器，每进行一次Minor GC，年龄加一，到了阈值会进入老年代；动态年龄判定，在survivor空间中相同年龄所有对象大于survivor的一半，该年龄以上的对象进入老年代。</p>
<hr>
<h4 id="类加载的时机">类加载的时机</h4>
<ol>
<li>
<p>使用new关键字实例化时，读取或设置一个类的静态字段时（对于final修饰的类常量，在调用时并不会触发被调用类的初始化，因为该常量已被编译到调用类的常量池字节码中），调用一个类的静态方法时。</p>
</li>
<li>
<p>使用java.lang.reflect包的方法对类进行反射调用时，类未被初始化。</p>
</li>
<li>
<p>初始化一个类时，父类没有被初始化，需先初始化父类（接口不要求父接口已初始化，除非用到了父类接口）。</p>
</li>
<li>
<p>虚拟机启动时初始化mian方法主类。</p>
</li>
<li>
<p>使用动态语言支持时。</p>
</li>
</ol>
<p>除此之外，其他任何情况都不会触发类的初始化，如通过子类调用父类的静态字段，不会初始化子类。</p>
<hr>
<h4 id="类加载过程">类加载过程</h4>
<ol>
<li>加载</li>
</ol>
<p>将类加载进方法区，生成代表该类的class对象，作为方法区该类的各种数据入口。</p>
<ol start="2">
<li>验证</li>
</ol>
<p>验证字节流是否符合class文件规范，确保class文件的字节流符合当前虚拟机规范。</p>
<ol start="3">
<li>准备</li>
</ol>
<p>为类变量分配内存并设置类变量初始值，除final类型的变量，其余都赋值为零或null或false。</p>
<ol start="4">
<li>解析</li>
</ol>
<p>将符号引用替换为直接引用</p>
<ol start="5">
<li>初始化</li>
</ol>
<p>执行类中Java代码，将初始值替换为真实赋值。</p>
<p>注意：初始化时代码执行是从上往下执行的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的类变量，只能赋值（在准备阶段已经分配了内存），不能访问（还没有赋真值，访问的值是无效的，这就不安全了）。</p>
<p><strong>子类和父类初始化顺序：</strong></p>
<p>1，在类加载的时候执行父类的static代码块，并且只执行一次（因为类只加载一次）；</p>
<p>2，执行子类的static代码块，并且只执行一次（因为类只加载一次）；</p>
<p>3，执行父类的类成员初始化，并且是从上往下按出现顺序执行；</p>
<p>4，执行父类的构造函数；</p>
<p>5，执行子类的类成员初始化，并且是从上往下按出现顺序执行。</p>
<p>6，执行子类的构造函数。</p>
<hr>
<h4 id="双亲委派模型">双亲委派模型</h4>
<p>Java中类加载器可分为三类：</p>
<ol>
<li>启动类加载器</li>
</ol>
<p>使用c++语言实现，负责加载lib目录中的类库，无法被Java程序直接引用。</p>
<ol start="2">
<li>扩展类加载器</li>
</ol>
<p>使用Java实现，负责加载lib\ext目录中的类库，开发之可以直接使用。</p>
<ol start="3">
<li>应用程序类加载器</li>
</ol>
<p>由ClassLoader实现，负责加载用户类路径（classpath）上指定的类库，开发者可以直接使用。</p>
<p>双亲委派模型的工作过程：如果一个类收到了类加载的请求，会首先把这个请求委派给父类加载器（使用组合关系来复用父加载器的代码），因此所有的加载请求都委派到顶层的启动类加载器，只有父类加载器无法完成这个加载请求，子加载器才会尝试自己去加载，这样保证了object类在程序中都是同一个类，保证了程序的稳定。</p>
]]></content>
    </entry>
</feed>